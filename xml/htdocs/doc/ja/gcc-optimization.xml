<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<!-- $Header: /var/cvsroot/gentoo/xml/htdocs/doc/en/gcc-optimization.xml,v 1.18 2010/07/27 00:24:29 nightmorph Exp $ -->

<guide>
<title>コンパイラ最適化ガイド</title>

<author title="Author">
  <mail link="nightmorph"/>
</author>

<abstract>
このガイドは、確かで安全なCFLAGSとCXXFLAGSを使ったコンパイル済みコードの最適化の導入を提供します。
</abstract>

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/2.5 -->
<license/>

<version>2</version>
<date>2010-07-26</date>

<chapter>
<title>はじめに</title>
<section>
<title>CFLAGSとCXXFLAGSとは？</title>
<body>

<p>
CFLAGSとCXXFLAGSは環境変数で、ソースコードをコンパイルするときに使う一種のスイッチとしてGNUコンパイラコレクション、いわゆるgccに渡されます。CFLAGSはCで書かれたコード、一方CXXFLAGSはC++で書かれたコード用です。
</p>

<p>
これらはプログラムのデバッグメッセージの量を減らすのに使われたり、
エラーや警告のレベルを増加させたり、また、もちろん生成されるコードの最適化にも使われたりします。
<uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Invoking-GCC.html#Invoking-GCC">GNU
gcc ハンドブック</uri>に利用可能なオプションとその働きの完全なリストが記載されています。
</p>

</body>
</section>
<section>
<title>どのように使われているのでしょうか？</title>
<body>

<p>
CFLAGSとCXXFLAGSは二通り使われ方があります。
一つ目はプログラムごとに、automakeにより生成されたMakefilesに書く方法です。
</p>

<p>
しかしながら、この方法はPortageツリーの中にあるパッケージをインストールする際に使うべきではありません。
その代わりに、CFLAGSとCXXFLAGSを<path>/etc/make.conf</path>で定義します。
この方法を使えば、全てのパッケージはあなたが定義したオプションでコンパイルされるでしょう。
</p>

<pre caption="/etc/make.confにあるCFLAGS">
CFLAGS="-march=athlon64 -O2 -pipe"
CXXFLAGS="${CFLAGS}"
</pre>

<p>
見てわかるとおり、CXXFLAGSはCFLAGSの中にある全てのオプションが設定されています。
これで失敗せずにあなたがやりたいことをほぼ満たします。
CXXFLAGSの中に追加のオプションを定義する必要はありません。
</p>

</body>
</section>
<section>
<title>よくある誤解</title>
<body>

<p>
CFLAGSとCXXFLAGSは、
ソースコードから小さくて早いバイナリを得るにはとても効果的な方法である一方で、
コード中の機能を損なったり、サイズを膨らませたり、実行時間を遅延させたり、
コンパイルの失敗さえも引き起こす場合もあります！
</p>

<p>
CFLAGSは特効薬ではありません。これらは自動的にあなたのシステムを早くしたり、
ディスク上のスペースが少なくなるようバイナリを縮めてはくれないでしょう。
たくさんのフラグをシステムを最適化する(もしくは"カリカリにチューニングする")目的で追加することは、
失敗するたしかな原因です。これらの誤解はあなたが利益を損なう結果を得るポイントです。
</p>

<p>
インターネットでは積極的なCFLAGSやCXXFLAGSの自慢も見受けられますが、
それらはいい影響を与えるよりも、悪影響を及ぼす可能性の方がはるかに高いです。
これらのフラグがmake.confの中の最初の場所にあるのは、特定の場所で、
特定の目的のために使用されることを想定している為であることを留意しておいてください。
とあるひとつのCFLAGがコードの１ビットを良くするからといって、
あなたのマシンにインストールされる全てをコンパイルするのに適しているという意味ではないのです！
</p>

</body>
</section>
<section>
<title>準備はできましたか？</title>
<body>

<p>
リスクを伴うことを理解したところで、
あなたのコンピュータのいくつかの確実で安全な最適化を見ていきましょう。
これらはあなたに良い利益をもたらし、次回<uri
link="http://bugs.gentoo.org">Bugzilla</uri>に問題をレポートするときに、開発者からあなたが
慕われるでしょう。
（問題が解決するかどうかを見るために、
大抵開発者は最低限のCFLAGSでパッケージの再コンパイルを要求するでしょう。
積極的なフラグはコードを破壊しうることを覚えておいてください。）
</p>

</body>
</section>
</chapter>

<chapter>
<title>最適化について</title>
<section>
<title>基本</title>
<body>

<p>
CFLAGSとCXXGLAGSを使うことによるゴールは、
あなたのシステム向けにあつらえた、
可能な限り早くて小さな、かつ完全に作用するコードを生成することです。
時には、これらの条件は相互に排他的ですので、
うまく動作すると知られている組み合わせを使い続けるでしょう。
理想をいえば、任意のCPUアーキテクチャに最適に通用するものがいいでしょう。
後ほど私たちは積極的なフラグについて言及するので、
あなたの探しているものもわかるでしょう。
私たちは<c>gcc</c>マニュアルに載っている全てのオプション(100個ほどあります)につては議論しませんが、基本的で最もよく知られているフラグをカバーしています。
</p>

<note>
フラグが実際にどう働くかわからないときはいつでも<uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.3.3/gcc/Optimize-Options.html#Optimize-Options">gccマニュアル</uri>の関連する章を参照してください。
もしそれでも悩まされるときは、Googleで検索したり、<c>gcc</c>
<uri link="http://gcc.gnu.org/lists.html">メーリングリスト</uri>を調べてみてください。
</note>

</body>
</section>
<section>
<title>-march</title>
<body>

<p>
まず最初に、一番重要なオプションは<c>-march</c>です。
これはあなたのプロセッサ<uri
link="http://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3">アーキテクチャ</uri>のためのコードを生成するようコンパイラに伝えます。つまり、とあるCPU種類向けのコードを生成すべきであるといっているのです。
CPUが違えば、異なる性能を持ち、異なる命令セットをサポートし、コードの実行方法も違います。
<c>-march</c>フラグは、あなたのCPUの全ての癖、命令セット、特徴、性能などに合わせて特化したコードを生成するようにコンパイラに伝えます。
</p>

<p>
たとえ<path>/etc/make.conf</path>に書いてあるCHOST変数を一般的なアーキテクチャに設定していても、
<c>-march</c>を設定してあれば、プログラムをあなたが指定したプロセッサ向けに最適化されるでしょう。
x86とx86-64のCPUは(とりわけ)<c>-march</c>フラグを使うべきです。
</p>

<p>
あなたはどんな種類のCPUを持っていますか？知りたいときは、以下のコマンドを実行しましょう:
</p>

<pre caption="CPU情報の検査">
$ <i>cat /proc/cpuinfo</i>
</pre>

<p>
では実際に<c>-march</c>を見てみましょう。この例は古いPentium Ⅲチップ向けです
</p>

<pre caption="/etc/make.conf: Pentium Ⅲ向け">
CFLAGS="-march=pentium3"
CXXFLAGS="${CFLAGS}"
</pre>

<p>
こちらは64bitのAMD製CPU用になります:

</p>

<pre caption="/etc/make.conf: AMD64向け">
CFLAGS="-march=athlon64"
CXXFLAGS="${CFLAGS}"
</pre>

<p>
もしあなたまだどんなCPUの種類を持っているのかわからない場合は、
<c>-march=native</c>を使うこともできるでしょう。
このフラグが設定されると、GCCはあなたのプロセッサを判定して、
自動的にふさわしいフラグが設定されるでしょう。
<brite>しかしながら、
このフラグは異なるCPU向けにパッケージをコンパイルする目的では使用すべきではありません！
</brite>
</p>

<p>
それで、もしあなたがひとつのコンピュータでパッケージをコンパイルしていて、
しかしそれらを別のコンピュータで実行させようとしている場合
(処理の早いコンピュータで古くて遅いマシンのためにビルドしているときなど)、
<c>-march=native</c>を使<e>わない</e>でください。
"Native"というのはコンパイルしているマシンのCPUタイプ<e>のみ</e>に特化して、
アプリケーションのコードを生成することを意味しています。
AMD製Athlon 64のCPU上で<c>-march=native</c>と共にビルドされたアプリケーションは、
古いVIA製C3というCPUでは実行することができないでしょう。
</p>

<p>
また、<c>-mtune</c>と<c>-mcpu</c>フラグも利用可能です。これらのフラグは
たいてい<c>-march</c>オプションが利用不可能な場合にのみ使われます。
例えば特定のプロセッサアーキテクチャは<c>-mtune</c>や<c>-mcpu</c>が必要になるかもしれません。
残念ながら、<c>gcc</c>の挙動はそれぞれのフラグの振る舞いが、
あるアーキテクチャから近いアーキテクチャであってもあまり一貫性がありません。
</p>

<p>
x86とx86-64のCPUでは、<c>-march</c>は正しいABIと全ての利用可能な命令セットを使って、
そのCPUに特化したコードを生成するでしょう。
そのため古くて異なるCPUとの後方互換性は持っていません。
もしあなたが現在Gentooを動かしているシステム以外でそのコードを走らせるつもりがないならば、
<c>-march</c>を使い続けてください。
あなたがi386やi686のような古いCPU向けにコードを生成する必要があるときのみ、
<c>-mtune</c>の使用を考慮するべきでしょう。
<c>-mtune</c>は<c>-march</c>よりも一般的なコードを生成します。
特定のコードにチューニングされているとはいえ、利用可能な命令セットやABIを考慮しないのです。
<c>-mcpu</c>はx86やx86-64のシステム上では非推奨となっているので、使わないでください。
</p>

<p>
x86/x86-64でない(SparcやAlpha、PowerPCのような)CPUでのみ、
<c>-march</c>の代わりに<c>-mtune</c>や<c>-mcpu</c>が必要になるでしょう。
これらのアーキテクチャ上では、<c>-mtune</c>/<c>-mcpu</c>は(x86/x86-64上での)<c>-march</c>と同じように振る舞うでしょう･･･しかし異なるフラグで、です。
繰り返しますが、<c>gcc</c>の振る舞いとフラグ名はアーキテクチャを超えて一貫していないので、
システムでどのフラグを使うべきなのかを決定するために<c>gcc</c><uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Submodel-Options.html#Submodel-Options">マニュアル</uri>
を必ず確認してください。
</p>

<note>
更なる<c>-march</c>/<c>-mtune</c>/<c>-mcpu</c>の設定についての情報は、
あなたのアーキテクチャに適した<uri
link="/doc/ja/handbook/">Gentooインストールハンドブック</uri>の５章を読んでみてください。
また、<c>gcc</c>マニュアルの<uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Submodel-Options.html#Submodel-Options">アーキテクチャ特有のオプション</uri>のリストに、
<c>-march</c>と<c>-mcpu</c>と<c>-mtune</c>の違いについてもっと詳しい説明が書いてあります。
</note>

</body>
</section>
<section>
<title>-O</title>
<body>

<p>
次は<c>-O</c>変数についてです。これは全体の最適化レベルをコントロールします。
特にこの最適化レベルを上げることによって、コードのコンパイルの時間が多少増えたり、
よりたくさんのメモリを使用するようになります。
</p>

<p>
<c>-O</c>の設定には５つあります。
<c>-O0</c>、<c>-O1</c>、<c>-O2</c>、<c>-O3</c>、そして<c>-Os</c>です。
これらの中からひとつだけ選び、
<path>/etc/make.conf</path>の中で使ってみてください。
</p>

<p>
<c>-O0</c>を除いて、<c>-O</c>の設定はいずれもいくつかの追加フラグを有効にします。
なので、どの<c>-O</c>レベルで、どのフラグが有効になるのかと、そのフラグにどんな効果があるのかを学ぶために、gccマニュアルの<uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Optimize-Options.html#Optimize-Options">最適化オプション</uri>
の章を読んで確認しましょう。
</p>

<p>
それぞれの最適化レベルについてみてみましょう:
</p>

<ul>
  <li>
    <c>-O0</c>: このレベル("O"のあとにゼロが続いてます)は、
    完全に最適化をオフにし、
    CFLAGSやCXXFLAGSの中に<c>-O</c>が定義されていない場合のデフォルトです。
    コードが最適化されないので、普通は使われません。
  </li>
  <li>
    <c>-O1</c>: これは最も基本的な最適化レベルです。
    コンパイラはコンパイル時間をたくさんかけることなく、
    早く小さなコードを生成しようと試みるでしょう。
    これはかなり基本的ですが、いつでもコンパイルはうまくいくはずです。
  </li>
  <li>
    <c>-O2</c>: <c>-O1</c>から更に踏み込みます。
    これは特別な理由がない限り<e>推奨される</e>最適化レベルです。
    <c>-O2</c>は<c>-O1</c>により有効になるものに加え、いくつかのフラグを有効にします。
    <c>-O2</c>を有効にすると、コンパイラはサイズを増えたり、
    たくさんの時間がかかったりしないように、コードのパフォーマンスを増加させようと試みます。
  </li>
  <li>
    <c>-O3</c>: これは最大の最適化レベルであり、また最もリスクが高いです。
    このオプションを有効にしてコンパイルすると長い時間がかかるでしょうし、
    事実<e>このフラグと<c>gcc</c> 4.xを使ってシステム全体を作るべきではありません。</e>
    <c>gcc</c>の振る舞いが3.xバージョンからかなり変わってしまっています。
    3.xでは、<c>-O3</c>はわずかに実行時間が<c>-O2</c>よりも早くなっていましたが、
    これはもはや<c>gcc</c> 4.xでは当てはまりません。
    全てのパッケージを<c>-O3</c>と共にコンパイルすることは、
    たくさんのメモリを必要とする大きなバイナリができあがり、
    さらにはコンパイルエラーや予期しないプログラムの動作(エラーを含む)をする確率が、
    かなり上昇します。
    プラス面よりもマイナス面が勝っていて、利益は少なくなるという法則を覚えておきましょう。
    <b><c>-O3</c>を使うことは<c>gcc</c> 4.xでは推奨されていません。</b>
  </li>
  <li>
    <c>-Os</c>: このレベルはあなたのコードをサイズを重視して最適化するでしょう。
    これは<c>-O2</c>オプションの中で、
    生成されるコードのサイズが増えないものを全て有効にします。
    CPUのキャッシュが小さかったり、
    ディスクストレージスペースが極端に限られている場合などに非常に有効でしょう。
    しかしながら、かなりの数の問題を引き起こし得るでしょう。それが、
    Portageツリーの中のたくさんのebuildでこのフラグが除外されている理由でもあります。
    <c>-Os</c>を使うことは推奨されていません。
  </li>
</ul>

<p>
前で言及したように、<c>-O2</c>が推奨される最適化レベルです。
もしパッケージのコンパイルが失敗する場合は、<c>-O3</c>を使っていないか確認してください。
フォールバック時の選択として、
CFLAGSとCXXFLAGSを<c>-O1</c>や<c>-O0 -g2 -ggdb</c>(エラー報告や可能性のある問題の調査向け)
のような低い最適化レベルの設定し、パッケージを再コンパイルしてください。
</p>

</body>
</section>
<section>
<title>-pipe</title>
<body>

<p>
よく使うフラグに<c>-pipe</c>があります。
このフラグ、実は生成されるコードには何の影響もありませんが、コンパイル処理が早くなります。
これは異なるステージのコンパイルをする間一時ファイルを使う代わりに、
より多くのメモリを使いますが、パイプを使うように指示します。
少ないメモリしかないシステムの場合、gccがもしかすると強制終了するかもしれません。
そのような場合はこのフラグを使わないでください。
</p>

</body>
</section>
<section>
<title>-fomit-frame-pointer</title>
<body>

<p>
これは生成されるコードのサイズを減少させるために設計されているフラグで、
とても広く使われています。
このフラグは、有効にしてもデバッグの邪魔をしないアーキテクチャでは(x86-64のような)、
全ての<c>-O</c>のレベル(<c>-O0</c>を除く)で有効になりますが、あなたはおそらくフラグを
手動で加えて有効にしなくてはならないでしょう。
GNU<c>gcc</c>マニュアルで、
<c>-O</c>を使うことによって全てのアーキテクチャで有効になると明記していないとはいえ、
x86アーキテクチャ上では明確に有効にする必要があるでしょう。
しかしながら、このフラグを使えば、デバッグはほとんど不可能になってしまいます。
</p>

<p>
特に、Javaで書かれたアプリケーションの不具合修正をとても難しくます。
もっとも、Javaだけがこのフラグの影響を受けるわけではありませんが。

このように、このフラグは役立つ一方でデバッグを難しくしているのです。
特にバックトレースは無駄になります。
しかしながら、そんなにソフトウェアデバッグを行う予定がなく、
他に<c>-ggdb</c>のようなデバッグ関連のCFLAGSを追加していないのであれば、
<c>-fomit-frame-pointer</c>を試しに使ってみてもいいでしょう。
</p>

<impo>

<c>-fomit-frame-pointer</c>と似ている<c>-momit-leaf-frame-pointer</c>フラグを組み合わせて使<e>わない</e>でください。
<c>-fomit-frame-pointer</c>が十分に正しく動くため、後者のフラグを使うことは推奨できません。
そのうえ、<c>-momit-leaf-frame-pointer</c>はコードの性能に悪影響を及ぼすことさえあります。
<!--
この情報元:
http://www.coyotegulch.com/products/acovea/aco5p4gcc40.html
-->
</impo>

</body>
</section>
<section>
<title>-msse, -msse2, -msse3, -mmmx, -m3dnow</title>
<body>

<p>
これらのフラグは、<uri
link="http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</uri>、<uri
link="http://en.wikipedia.org/wiki/SSE2">SSE2</uri>、<uri
link="http://en.wikipedia.org/wiki/SSSE3">SSE3</uri>、<uri
link="http://en.wikipedia.org/wiki/MMX">MMX</uri>、<uri
link="http://en.wikipedia.org/wiki/3dnow">3DNow!</uri>のx86とx86-64アーキテクチャ向け命令セットを有効にします。
他にも有用な数学用機能の向上はいくつか含んでいるのですが、
これらは主にマルチメディアやゲーム、その他の浮動小数点を多用するコンピューテングタスクに有用です。
これらの命令セットは最近のCPUの中に多く見受けられます。
</p>

<impo>
あなたのCPUがこれらをサポートしているかどうかは<c>cat /proc/cpuinfo</c>を走らせて確認してください。
その出力が追加されているあらゆる命令セットを含んでいることでしょう。
<b>pni</b>が実際はSSE3の別名であることに注意してください。
</impo>

<p>
通常、正しい<c>-march</c>を使っている限り、
これらのどのフラグも<path>/etc/make.conf</path>に加える必要はありません
(例えば<c>-march=nocona</c>は<c>-msse3</c>も含まれます)。
いくつかの注意すべき例外は、<c>-march</c>による(SSE3のような)命令セットの埋め込みがサポートされていない新しいVIAやAMD64のCPUです。
それらのCPUのために、<c>cat /proc/cpuinfo</c>の出力を確認した後に、
ふさわしい追加フラグを有効にする必要があるでしょう。
</p>

<note>
それらの命令セットを有効にするためにはどのCPUタイプが適しているのか、
x86とx86-64特有のフラグ<uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options">リスト</uri>
を確認すべきです。
もし命令がリストの中にあったら、明記する必要はありません。
なぜならそれらは正しい<c>-march</c>を使えば有効になるでしょうから。
</note>

</body>
</section>
</chapter>

<chapter>
<title>最適化FAQ</title>
<section>
<title>-funroll-loops -fomg-optimizeを使ったら早くなったんだけど！</title>
<body>

<p>
いいえ違います、だれかがあなたにそのフラグで良くなると信じ込ませているので、
あなたは早くなったと思っているだけです。
システム全体で積極的なフラグを使うことはあなたのアプリケーションを傷つけるでしょう。
<c>gcc</c> <uri
link="http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Optimize-Options.html#Optimize-Options">マニュアル</uri>では<c>-funroll-loops</c>と<c>-funroll-all-loops</c>を使うとコードは大きくなり、
実行も遅くなると述べています。
またいくつかの理由から、これらの二つのフラグと同時に、
<c>-ffast-math</c>や<c>-fforce-mem</c>や<c>-fforce-addr</c>などの似たようなフラグが、
速度を最大限誇示したいライサー達(訳注:カリカリにチューンアップするような人)の間で、
とても人気を博しています。
</p>

<p>
ここで本当に問題なのは、これらのフラグは危険なほどに攻撃的なフラグということです。
それらのフラグが何をしているのかを知るために<uri link="http://forums.gentoo.org">Gentoo Forums</uri>
と<uri link="http://bugs.gentoo.org">Bugzilla</uri>あたりをよく見てください。
本当にいいことしてないですよ！
</p>

<p>
それらのフラグをCFLAGSやCXXFLAGSにグローバルに使う必要はありません。
それらはパフォーマンスに悪影響を及ぼすだけでしょう。
それらのフラグが、
あなたを最先端で動いているハイパフォーマンスなシステムを持っている人かのように見せるかもしれませんが、
しかしそれらはなにもしないどころか、コードを膨張させ、あなたのバグ報告をINVALIDやWONTFIXにしてしまうのです。
</p>

<p>
あなたはそのような危険なフラグを使う必要はありません。<b>使わないでください。</b>
<c>-march</c>、<c>-O</c>、<c>-pipe</c>という基本を守り通してください。
</p>

</body>
</section>
<section>
<title>3より大きい-Oレベルは何がありますか？</title>
<body>

<p>
何人かのユーザーが、<c>-O4</c>や<c>-O9</c>などを使うことによってもっといいパフォーマンスを得たと誇張していますが、3より大きい<c>-O</c>レベルは何の効果もありません。
コンパイラは<c>-O4</c>のようなCFLAGSも許容するでしょうが、それらは実質何もしないのです。
最適化レベルを<c>-O3</c>にしてくれるだけで、それ以上は何もありません。
</p>

<p>
もっと証拠が必要ですか？<c>gcc</c>の<uri
link="http://gcc.gnu.org/viewcvs/trunk/gcc/opts.c?revision=124622&amp;view=markup">ソースコード
</uri>を検証してください:
</p>

<pre caption="-O オプション部分のソースコード">
if (optimize >= 3)
    {
      flag_inline_functions = 1;
      flag_unswitch_loops = 1;
      flag_gcse_after_reload = 1;
      /* Allow even more virtual operators.  */
      set_param_value ("max-aliased-vops", 1000);
      set_param_value ("avg-aliased-vops", 3);
    }
</pre>

<p>
見てのとおり、どんな3より大きい数字でも<c>-O3</c>として扱われます。
</p>

</body>
</section>
<section>
<title>冗長なフラグ指定について</title>
<body>

<p>
よくいろいろな<c>-O</c>レベルを有効にしているCFLAGSとCXXFLAGSが
<path>/etc/make.conf</path>の中に冗長に定義してあるのをみかけます。
これはときどき知識不足から行われるのですが、
フラグフィルタやフラグ置換によって回避されます。
</p>

<p>
フラグフィルタ/置換はたいていPortageツリーの中にあるebuildで行われています。
大抵は、特定の<c>-O</c>レベルでパッケージをコンパイルすると失敗するため、
もしくはそのソースコードが他の追加のフラグのためにとても敏感である場合です。
ebuildはどちらの場合も、全部/一部のCFLAGSとCXXFLAGSを除外するか、
もしくは異なる<c>-O</c>レベルに置換するでしょう。
</p>

<p>
<uri
link="http://devmanual.gentoo.org/ebuild-writing/functions/src_compile/build-environment/index.html">Gentoo開発者マニュアル</uri>どこにどのようにしてフラグフィルタ/置換が動いているのかの概略があります。
</p>

<p>
それは特定のレベルのためのフラグを冗長にリストアップすることによって、フィルタリングを回避することが可能で、例えば<c>-O3</c>であれば、次のようにします:
</p>

<pre caption="冗長なCFLAGSの例">
CFLAGS="-O3 -finline-functions -funswitch-loops"
</pre>

<p>
しかしながら、<brite>これはスマートじゃありません</brite>。
CFLAGSは理由があってフィルタされるのです！
フラグがフィルタされるとき、
それらのフラグでパッケージをビルドすると安全でないことを意味します。
明らかにわかってるのは、
<c>-O3</c>によって有効になるフラグのいくつかが特定のパッケージで問題を引き起こす場合、
そのレベルと共にあなたのシステムをコンパイルすることは安全では<e>ありません</e>。
そのため、それらのパッケージをメンテナンスしている開発者の"裏をかく"ことを試みるべきではありません。
<e>開発者を信用してください</e>。
フラグフィルタとフラグ置換はあなたの利益になるから行われているのです！
もしebuildに代替のフラグが定義されていても、それを回避しようとしないでください。
</p>

<p>
あなたが歓迎しないフラグと共にコンパイルを行っているとき、
ほとんどの場合問題は起こり続けるでしょう。
もしあなたがBugzillaにトラブルをレポートするときは、
<path>/etc/make.conf</path>に書いているフラグを容易に見えるようにして、
更にそれらのフラグを指定しないで再度コンパイルすることを指示されます。
初めから冗長なフラグを指定しないことで、再コンパイルする手間を省いてください！
あなたが開発者よりよく知っていると根拠なく無意識に決めつけないでください。
</p>

</body>
</section>
<section>
<title>LDFLAGSについては？</title>
<body>

<p>
Gentoo開発者がすでに基本的で安全なLDFLAGSを基本プロファイルにセットしているので、
あなたがそれらを変更する必要はありません。
</p>

</body>
</section>
<section>
<title>パッケージごとにフラグをセットできますか？</title>
<body>

<p>
いくつか強制的にPortageにやらせようとする<uri
link="http://forums.gentoo.org/viewtopic-p-3832057.html#3832057">かなり強引なやり方</uri>がありますが、CFLAGSや他の変数をパッケージごとに定義する方法はサポートされていません。
</p>

<warn>
パッケージごとに強制的にフラグをセットしようと<e>すべきではありません</e>。
なぜならまったくサポートされないやり方ですし、バグレポートをとても複雑にするでしょう。
あなたのフラグを<path>/etc/make.conf</path>でシステム全体に定義するだけに留めておいてください。
</warn>

</body>
</section>
</chapter>

<chapter>
<title>資料</title>
<section>
<body>

<p>
以下のいくつかの資料が更なる最適化への理解の助けになるでしょう:
</p>

<ul>
  <li>
    <uri link="http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/">GNU gccマニュアル</uri>
  </li>
  <li>
    <uri link="/doc/en/handbook/">Gentooインストールハンドブック</uri>
  </li>
  <li><c>man make.conf</c></li>
  <li><uri link="http://ja.wikipedia.org">Wikipedia</uri></li>
  <li>
    <uri link="http://www.coyotegulch.com/products/acovea/">Acovea</uri>は、
    コンパイラのフラグが、
    どのように作用・影響して生成されるコードの違いを生むのかを測定するのに役に立つかもしれない、
    ベンチマークとテストソフトウェアです。
    もっとも、それらのコードの提案はシステム全体にふさわしいわけではありませんが。
    Portageでも次のコマンドで利用可能です:<c>emerge acovea</c>
  </li>
  <li><uri link="http://forums.gentoo.org">Gentooフォーラム</uri></li>
</ul>

</body>
</section>
</chapter>
</guide>
